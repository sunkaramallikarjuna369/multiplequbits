<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple-Qubit States - Interactive Quantum Computing Guide</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 60px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            margin-bottom: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #00d4ff, #ff6b9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }
        
        .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            color: #b8b8d1;
        }
        
        #canvas-container {
            height: 500px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            margin-bottom: 40px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        
        .canvas-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #00d4ff;
        }
        
        .concepts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .concept-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        
        .concept-card:hover {
            transform: translateY(-10px);
            background: rgba(255, 255, 255, 0.1);
            border-color: #00d4ff;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
        }
        
        .concept-number {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(135deg, #00d4ff, #ff6b9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        
        .concept-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .concept-description {
            font-size: 0.95em;
            line-height: 1.6;
            opacity: 0.8;
            color: #b8b8d1;
        }
        
        .intro-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            margin-bottom: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h2 {
            color: #00d4ff;
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        .highlight {
            background: rgba(0, 212, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #00d4ff;
        }
        
        a {
            color: inherit;
            text-decoration: none;
        }
        
        ul {
            margin-left: 20px;
            line-height: 1.8;
        }
        
        li {
            margin: 8px 0;
        }
        
        .key-concepts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .key-concept-item {
            background: rgba(0, 212, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border-left: 3px solid #00d4ff;
        }
        
        .key-concept-item strong {
            color: #00d4ff;
        }
        
        .formula-preview {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 1.2em;
            border-left: 3px solid #ff6b9d;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            
            .concepts-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multiple-Qubit States</h1>
            <p class="subtitle">Interactive 3D Visualizations & Comprehensive Guide to Multi-Qubit Quantum Systems</p>
        </header>
        
        <div id="canvas-container">
            <div class="canvas-label">Interactive Multi-Qubit State Visualization - Drag to rotate</div>
        </div>
        
        <div class="intro-section">
            <h2>Welcome to Multiple-Qubit States!</h2>
            <p>This interactive guide explores the fascinating world of <span class="highlight">multiple-qubit quantum systems</span>. While a single qubit is represented on the Bloch sphere, real quantum computation involves multiple qubits that can interact, become entangled, and represent exponentially large Hilbert spaces.</p>
            
            <div class="formula-preview">
                If one qubit lives in C<sup>2</sup>, then n qubits live in C<sup>2<sup>n</sup></sup> - an exponentially large space!
            </div>
            
            <p style="margin-top: 20px;">In this guide, you will learn:</p>
            <div class="key-concepts">
                <div class="key-concept-item">
                    <strong>Tensor Products</strong><br>
                    How individual qubit spaces combine into multi-qubit systems
                </div>
                <div class="key-concept-item">
                    <strong>Entanglement</strong><br>
                    Quantum correlations with no classical counterpart
                </div>
                <div class="key-concept-item">
                    <strong>Bell States</strong><br>
                    Maximally entangled two-qubit states
                </div>
                <div class="key-concept-item">
                    <strong>Quantum Gates</strong><br>
                    CNOT and multi-qubit operations
                </div>
            </div>
            
            <p style="margin-top: 20px;">Each concept includes:</p>
            <ul>
                <li>Interactive 3D visualizations using Three.js</li>
                <li>Python code demonstrations with NumPy</li>
                <li>Mathematical foundations and formulas</li>
                <li>Quantum computing applications</li>
                <li>Intuitive explanations and examples</li>
            </ul>
        </div>
        
        <h2 style="text-align: center; margin-bottom: 30px;">Explore All 13 Concepts</h2>
        
        <div class="concepts-grid">
            <a href="01-introduction/index.html">
                <div class="concept-card">
                    <div class="concept-number">01</div>
                    <div class="concept-title">Introduction</div>
                    <div class="concept-description">From single qubits to multi-qubit systems. Understanding the exponential growth of Hilbert spaces.</div>
                </div>
            </a>
            
            <a href="02-tensor-product/index.html">
                <div class="concept-card">
                    <div class="concept-number">02</div>
                    <div class="concept-title">Tensor Product Structure</div>
                    <div class="concept-description">Two-qubit basis states and Kronecker product form. Building composite quantum systems.</div>
                </div>
            </a>
            
            <a href="03-product-entangled/index.html">
                <div class="concept-card">
                    <div class="concept-number">03</div>
                    <div class="concept-title">Product vs Entangled States</div>
                    <div class="concept-description">Separable states vs quantum entanglement. Understanding non-classical correlations.</div>
                </div>
            </a>
            
            <a href="04-bell-states/index.html">
                <div class="concept-card">
                    <div class="concept-number">04</div>
                    <div class="concept-title">Bell States</div>
                    <div class="concept-description">The four maximally entangled two-qubit states. Orthonormal basis for entanglement.</div>
                </div>
            </a>
            
            <a href="05-dimension-growth/index.html">
                <div class="concept-card">
                    <div class="concept-number">05</div>
                    <div class="concept-title">Dimension Growth</div>
                    <div class="concept-description">Exponential scaling: n qubits = 2^n dimensions. The source of quantum parallelism.</div>
                </div>
            </a>
            
            <a href="06-quantum-gates/index.html">
                <div class="concept-card">
                    <div class="concept-number">06</div>
                    <div class="concept-title">Quantum Gates</div>
                    <div class="concept-description">Single-qubit gates on multi-qubit systems. The CNOT gate and controlled operations.</div>
                </div>
            </a>
            
            <a href="07-generating-entanglement/index.html">
                <div class="concept-card">
                    <div class="concept-number">07</div>
                    <div class="concept-title">Generating Entanglement</div>
                    <div class="concept-description">Creating Bell states with Hadamard and CNOT. The entanglement circuit.</div>
                </div>
            </a>
            
            <a href="08-measurement/index.html">
                <div class="concept-card">
                    <div class="concept-number">08</div>
                    <div class="concept-title">Measurement</div>
                    <div class="concept-description">Measuring multi-qubit systems. Probability distributions and state collapse.</div>
                </div>
            </a>
            
            <a href="09-n-qubit-states/index.html">
                <div class="concept-card">
                    <div class="concept-number">09</div>
                    <div class="concept-title">General n-Qubit States</div>
                    <div class="concept-description">Expressing arbitrary n-qubit pure states. Computational basis and normalization.</div>
                </div>
            </a>
            
            <a href="10-partial-trace/index.html">
                <div class="concept-card">
                    <div class="concept-number">10</div>
                    <div class="concept-title">Partial Trace & Subsystems</div>
                    <div class="concept-description">Reduced density matrices. Describing parts of larger quantum systems.</div>
                </div>
            </a>
            
            <a href="11-ghz-state/index.html">
                <div class="concept-card">
                    <div class="concept-number">11</div>
                    <div class="concept-title">GHZ State</div>
                    <div class="concept-description">Three-qubit maximally entangled state. Applications in quantum communication.</div>
                </div>
            </a>
            
            <a href="12-exercises/index.html">
                <div class="concept-card">
                    <div class="concept-number">12</div>
                    <div class="concept-title">Exercises</div>
                    <div class="concept-description">Practice problems with interactive solutions. Test your understanding of multi-qubit systems.</div>
                </div>
            </a>
            
            <a href="13-summary/index.html">
                <div class="concept-card">
                    <div class="concept-number">13</div>
                    <div class="concept-title">Summary</div>
                    <div class="concept-description">Complete overview with key takeaways. Quick reference for all multi-qubit concepts.</div>
                </div>
            </a>
        </div>
    </div>
    
    <script>
        let scene, camera, renderer;
        let qubits = [];
        let entanglementLines = [];
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(8, 6, 12);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            createScene();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0xff6b9d, 0.8, 100);
            pointLight2.position.set(-10, -5, 10);
            scene.add(pointLight2);
            
            window.addEventListener('resize', onWindowResize, false);
            
            // Mouse interaction
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', () => isDragging = true);
            container.addEventListener('mouseup', () => isDragging = false);
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };
                    scene.rotation.y += deltaMove.x * 0.005;
                    scene.rotation.x += deltaMove.y * 0.005;
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            
            animate();
        }
        
        function createScene() {
            // Create grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x1a1a3e, 0x0a0a1e);
            scene.add(gridHelper);
            
            // Create multiple Bloch spheres representing qubits
            const qubitPositions = [
                { x: -4, y: 0, z: 0 },
                { x: 0, y: 0, z: 0 },
                { x: 4, y: 0, z: 0 }
            ];
            
            const colors = [0x00d4ff, 0xff6b9d, 0xffd700];
            
            qubitPositions.forEach((pos, index) => {
                const qubit = createBlochSphere(pos.x, pos.y, pos.z, colors[index]);
                qubits.push(qubit);
            });
            
            // Create entanglement lines
            createEntanglementLines();
        }
        
        function createBlochSphere(x, y, z, color) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            // Sphere wireframe
            const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: color,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            // Axes
            const axesLength = 2;
            const axesMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            
            // Z axis
            const zGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -axesLength, 0),
                new THREE.Vector3(0, axesLength, 0)
            ]);
            const zAxis = new THREE.Line(zGeometry, axesMaterial);
            group.add(zAxis);
            
            // X axis
            const xGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-axesLength, 0, 0),
                new THREE.Vector3(axesLength, 0, 0)
            ]);
            const xAxis = new THREE.Line(xGeometry, axesMaterial);
            group.add(xAxis);
            
            // State vector (arrow)
            const stateVector = createStateVector(color);
            group.add(stateVector);
            group.stateVector = stateVector;
            
            scene.add(group);
            return group;
        }
        
        function createStateVector(color) {
            const group = new THREE.Group();
            
            // Arrow shaft
            const shaftGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.3, 16);
            const shaftMaterial = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = 0.65;
            group.add(shaft);
            
            // Arrow head
            const headGeometry = new THREE.ConeGeometry(0.15, 0.3, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.45;
            group.add(head);
            
            return group;
        }
        
        function createEntanglementLines() {
            // Create glowing lines between qubits to represent entanglement
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xff6b9d,
                transparent: true,
                opacity: 0.6
            });
            
            // Line between qubit 0 and 1
            const line1Geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-4, 0, 0),
                new THREE.Vector3(0, 0, 0)
            ]);
            const line1 = new THREE.Line(line1Geometry, lineMaterial);
            scene.add(line1);
            entanglementLines.push(line1);
            
            // Line between qubit 1 and 2
            const line2Geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(4, 0, 0)
            ]);
            const line2 = new THREE.Line(line2Geometry, lineMaterial);
            scene.add(line2);
            entanglementLines.push(line2);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Animate state vectors
            qubits.forEach((qubit, index) => {
                const phase = index * Math.PI * 2 / 3;
                qubit.stateVector.rotation.x = Math.sin(time + phase) * 0.5;
                qubit.stateVector.rotation.z = Math.cos(time * 0.7 + phase) * 0.3;
            });
            
            // Pulse entanglement lines
            entanglementLines.forEach((line, index) => {
                line.material.opacity = 0.3 + Math.sin(time * 2 + index) * 0.3;
            });
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
