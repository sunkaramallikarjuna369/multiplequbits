<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction - Multiple-Qubit States</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Concept 1: Introduction</h1>
            <p class="subtitle">From Single Qubits to Multi-Qubit Systems</p>
        </header>

        <nav class="nav-buttons">
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../02-tensor-product/index.html" class="btn btn-secondary">Next: Tensor Product</a>
        </nav>

        <div class="section full-width">
            <h2>Interactive Visualization: Single vs Multi-Qubit Systems</h2>
            <div id="canvas-container"></div>
            <p style="text-align: center; margin-top: 10px; opacity: 0.8;">
                Drag to rotate - Watch how adding qubits exponentially increases the state space
            </p>
        </div>

        <div class="content-grid">
            <div class="section">
                <h2>The Journey Beyond Single Qubits</h2>
                <p>So far, we've seen how a single qubit is represented on the Bloch sphere. Real quantum computation, however, involves <span class="highlight">multiple qubits</span> that can interact, become entangled, and represent exponentially large Hilbert spaces.</p>
                
                <div class="key-point">
                    <strong>Key Insight:</strong> If one qubit is described by a 2-dimensional complex vector space C<sup>2</sup>, then an n-qubit system lives in a 2<sup>n</sup>-dimensional complex Hilbert space.
                </div>
                
                <div class="formula">
                    H<sub>n</sub> = C<sup>2<sup>n</sup></sup>
                </div>
                
                <p>Each qubit contributes one factor of C<sup>2</sup> through the <span class="highlight">tensor product</span>.</p>
            </div>

            <div class="section">
                <h2>Why Multiple Qubits Matter</h2>
                <p>The power of quantum computing comes from the ability to work with multiple qubits simultaneously:</p>
                
                <ul>
                    <li><strong>Exponential State Space:</strong> n qubits can represent 2<sup>n</sup> states simultaneously</li>
                    <li><strong>Quantum Parallelism:</strong> Operations can be performed on all states at once</li>
                    <li><strong>Entanglement:</strong> Qubits can be correlated in ways impossible classically</li>
                    <li><strong>Quantum Algorithms:</strong> Shor's, Grover's, and others exploit multi-qubit properties</li>
                </ul>
                
                <div class="example">
                    <h3>Scaling Example</h3>
                    <p>A 50-qubit quantum computer can represent 2<sup>50</sup> = 1,125,899,906,842,624 states simultaneously - more than a quadrillion!</p>
                </div>
            </div>

            <div class="section full-width">
                <h2>The Hilbert Space Structure</h2>
                
                <p>For a system of n qubits, the state space is constructed using the tensor product:</p>
                
                <div class="formula">
                    H<sub>n</sub> = C<sup>2</sup> ⊗ C<sup>2</sup> ⊗ ... ⊗ C<sup>2</sup> (n times) = C<sup>2<sup>n</sup></sup>
                </div>
                
                <div class="basis-states">
                    <div class="basis-state-card">
                        <h4>1 Qubit</h4>
                        <p>Dimension: 2</p>
                        <p>Basis: |0⟩, |1⟩</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>2 Qubits</h4>
                        <p>Dimension: 4</p>
                        <p>Basis: |00⟩, |01⟩, |10⟩, |11⟩</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>3 Qubits</h4>
                        <p>Dimension: 8</p>
                        <p>Basis: |000⟩ to |111⟩</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>n Qubits</h4>
                        <p>Dimension: 2<sup>n</sup></p>
                        <p>Basis: 2<sup>n</sup> orthonormal states</p>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Single Qubit Review</h2>
                <p>A single qubit state is written as:</p>
                
                <div class="formula">
                    |ψ⟩ = α|0⟩ + β|1⟩
                </div>
                
                <p>Where:</p>
                <ul>
                    <li>α, β are complex amplitudes</li>
                    <li>|α|<sup>2</sup> + |β|<sup>2</sup> = 1 (normalization)</li>
                    <li>|α|<sup>2</sup> = probability of measuring |0⟩</li>
                    <li>|β|<sup>2</sup> = probability of measuring |1⟩</li>
                </ul>
                
                <p>This lives in a 2-dimensional Hilbert space.</p>
            </div>

            <div class="section">
                <h2>Two Qubit Preview</h2>
                <p>A two-qubit state is written as:</p>
                
                <div class="formula">
                    |ψ⟩ = α<sub>00</sub>|00⟩ + α<sub>01</sub>|01⟩ + α<sub>10</sub>|10⟩ + α<sub>11</sub>|11⟩
                </div>
                
                <p>With normalization:</p>
                <div class="formula">
                    |α<sub>00</sub>|<sup>2</sup> + |α<sub>01</sub>|<sup>2</sup> + |α<sub>10</sub>|<sup>2</sup> + |α<sub>11</sub>|<sup>2</sup> = 1
                </div>
                
                <p>This lives in a 4-dimensional Hilbert space - we need 4 complex numbers to describe it!</p>
            </div>

            <div class="section full-width">
                <h2>Python Example: State Space Dimensions</h2>
                
                <div class="code-block">
<pre>import numpy as np

# Single qubit state
single_qubit = np.array([1/np.sqrt(2), 1/np.sqrt(2)])
print(f"Single qubit dimension: {len(single_qubit)}")
print(f"Single qubit state: {single_qubit}")

# Two qubit state (tensor product)
qubit1 = np.array([1/np.sqrt(2), 1/np.sqrt(2)])
qubit2 = np.array([1, 0])
two_qubit = np.kron(qubit1, qubit2)
print(f"\nTwo qubit dimension: {len(two_qubit)}")
print(f"Two qubit state: {two_qubit}")

# Three qubit state
qubit3 = np.array([1, 0])
three_qubit = np.kron(two_qubit, qubit3)
print(f"\nThree qubit dimension: {len(three_qubit)}")
print(f"Three qubit state: {three_qubit}")

# General formula
for n in range(1, 11):
    print(f"{n} qubits: {2**n} dimensional Hilbert space")</pre>
                </div>
            </div>

            <div class="section full-width">
                <h2>Key Takeaways</h2>
                <div class="key-point">
                    <ul>
                        <li>Multi-qubit systems live in exponentially large Hilbert spaces</li>
                        <li>n qubits require 2<sup>n</sup> complex amplitudes to describe</li>
                        <li>The tensor product combines individual qubit spaces</li>
                        <li>This exponential scaling enables quantum parallelism</li>
                        <li>Entanglement creates correlations impossible in classical systems</li>
                    </ul>
                </div>
            </div>
        </div>

        <nav class="nav-buttons">
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../02-tensor-product/index.html" class="btn btn-secondary">Next: Tensor Product</a>
        </nav>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let spheres = [];
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 8, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            createVisualization();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function createVisualization() {
            // Create visual representation of dimension growth
            // 1 qubit - 2 points
            createDimensionGroup(-8, 0, 0, 1, 0x00d4ff);
            
            // 2 qubits - 4 points
            createDimensionGroup(0, 0, 0, 2, 0xff6b9d);
            
            // 3 qubits - 8 points
            createDimensionGroup(8, 0, 0, 3, 0xffd700);
            
            // Labels
            addLabel(-8, -3, 0, "1 Qubit\n2 states");
            addLabel(0, -3, 0, "2 Qubits\n4 states");
            addLabel(8, -3, 0, "3 Qubits\n8 states");
        }
        
        function createDimensionGroup(x, y, z, numQubits, color) {
            const numStates = Math.pow(2, numQubits);
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            // Create spheres for each basis state
            const radius = 0.3;
            const spread = numQubits * 0.8;
            
            for (let i = 0; i < numStates; i++) {
                const angle = (i / numStates) * Math.PI * 2;
                const layerY = (i % 2) * 1.5 - 0.75;
                const layerRadius = spread;
                
                const sphereX = Math.cos(angle) * layerRadius;
                const sphereZ = Math.sin(angle) * layerRadius;
                
                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(sphereX, layerY, sphereZ);
                group.add(sphere);
                spheres.push({ mesh: sphere, baseY: layerY, phase: i });
            }
            
            // Add connecting lines
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.3 
            });
            
            for (let i = 0; i < numStates; i++) {
                for (let j = i + 1; j < numStates; j++) {
                    if (Math.random() > 0.5) continue; // Only some connections
                    const points = [];
                    const angle1 = (i / numStates) * Math.PI * 2;
                    const angle2 = (j / numStates) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        Math.cos(angle1) * spread,
                        (i % 2) * 1.5 - 0.75,
                        Math.sin(angle1) * spread
                    ));
                    points.push(new THREE.Vector3(
                        Math.cos(angle2) * spread,
                        (j % 2) * 1.5 - 0.75,
                        Math.sin(angle2) * spread
                    ));
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    group.add(line);
                }
            }
            
            scene.add(group);
        }
        
        function addLabel(x, y, z, text) {
            // Create a simple plane with text texture
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, 256, 128);
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            const lines = text.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, 128, 40 + i * 30);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(4, 2, 1);
            scene.add(sprite);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            spheres.forEach((item, index) => {
                item.mesh.position.y = item.baseY + Math.sin(time * 2 + item.phase) * 0.2;
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
