<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tensor Product Structure - Multiple-Qubit States</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Concept 2: Tensor Product Structure</h1>
            <p class="subtitle">Building Multi-Qubit States from Single Qubits</p>
        </header>

        <nav class="nav-buttons">
            <a href="../01-introduction/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../03-product-entangled/index.html" class="btn btn-secondary">Next</a>
        </nav>

        <div class="section full-width">
            <h2>Interactive Tensor Product Visualization</h2>
            <div id="canvas-container"></div>
            <p style="text-align: center; margin-top: 10px; opacity: 0.8;">
                Watch how two single-qubit states combine into a four-dimensional two-qubit state
            </p>
        </div>

        <div class="content-grid">
            <div class="section">
                <h2>Two-Qubit Basis</h2>
                <p>The state of two qubits is written as:</p>
                
                <div class="formula">
                    |ψ⟩ = Σ<sub>i,j∈{0,1}</sub> α<sub>ij</sub>|i⟩ ⊗ |j⟩
                </div>
                
                <p>Expanded form:</p>
                <div class="formula">
                    |ψ⟩ = α<sub>00</sub>|00⟩ + α<sub>01</sub>|01⟩ + α<sub>10</sub>|10⟩ + α<sub>11</sub>|11⟩
                </div>
                
                <p>With normalization:</p>
                <div class="formula">
                    |α<sub>00</sub>|<sup>2</sup> + |α<sub>01</sub>|<sup>2</sup> + |α<sub>10</sub>|<sup>2</sup> + |α<sub>11</sub>|<sup>2</sup> = 1
                </div>
            </div>

            <div class="section">
                <h2>Computational Basis</h2>
                <p>The <span class="highlight">computational basis</span> for two qubits is:</p>
                
                <div class="formula">
                    {|00⟩, |01⟩, |10⟩, |11⟩}
                </div>
                
                <p>Each basis vector is a <span class="highlight">tensor product</span> of single-qubit basis states:</p>
                
                <div class="basis-states">
                    <div class="basis-state-card">
                        <h4>|00⟩</h4>
                        <p>|0⟩ ⊗ |0⟩</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>|01⟩</h4>
                        <p>|0⟩ ⊗ |1⟩</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>|10⟩</h4>
                        <p>|1⟩ ⊗ |0⟩</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>|11⟩</h4>
                        <p>|1⟩ ⊗ |1⟩</p>
                    </div>
                </div>
            </div>

            <div class="section full-width">
                <h2>Kronecker Product Form</h2>
                <p>If we have two single-qubit states as column vectors:</p>
                
                <div class="formula">
                    |a⟩ = [a<sub>0</sub>, a<sub>1</sub>]<sup>T</sup>, |b⟩ = [b<sub>0</sub>, b<sub>1</sub>]<sup>T</sup>
                </div>
                
                <p>Then their tensor product is:</p>
                
                <div class="formula">
                    |a⟩ ⊗ |b⟩ = [a<sub>0</sub>b<sub>0</sub>, a<sub>0</sub>b<sub>1</sub>, a<sub>1</sub>b<sub>0</sub>, a<sub>1</sub>b<sub>1</sub>]<sup>T</sup>
                </div>
                
                <div class="example">
                    <h3>Concrete Example</h3>
                    <p>Let |a⟩ = |+⟩ = [1/√2, 1/√2]<sup>T</sup> and |b⟩ = |0⟩ = [1, 0]<sup>T</sup></p>
                    <div class="formula">
                        |+⟩ ⊗ |0⟩ = [1/√2 · 1, 1/√2 · 0, 1/√2 · 1, 1/√2 · 0]<sup>T</sup><br>
                        = [1/√2, 0, 1/√2, 0]<sup>T</sup><br>
                        = (1/√2)|00⟩ + (1/√2)|10⟩
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Vector Representation</h2>
                <p>The four basis states as column vectors:</p>
                
                <div class="basis-states">
                    <div class="basis-state-card">
                        <h4>|00⟩</h4>
                        <div class="formula">[1, 0, 0, 0]<sup>T</sup></div>
                    </div>
                    <div class="basis-state-card">
                        <h4>|01⟩</h4>
                        <div class="formula">[0, 1, 0, 0]<sup>T</sup></div>
                    </div>
                    <div class="basis-state-card">
                        <h4>|10⟩</h4>
                        <div class="formula">[0, 0, 1, 0]<sup>T</sup></div>
                    </div>
                    <div class="basis-state-card">
                        <h4>|11⟩</h4>
                        <div class="formula">[0, 0, 0, 1]<sup>T</sup></div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Tensor Product Properties</h2>
                <ul>
                    <li><strong>Bilinearity:</strong><br>
                        (a|ψ⟩ + b|φ⟩) ⊗ |χ⟩ = a(|ψ⟩ ⊗ |χ⟩) + b(|φ⟩ ⊗ |χ⟩)</li>
                    <li><strong>Associativity:</strong><br>
                        (|ψ⟩ ⊗ |φ⟩) ⊗ |χ⟩ = |ψ⟩ ⊗ (|φ⟩ ⊗ |χ⟩)</li>
                    <li><strong>Not Commutative:</strong><br>
                        |ψ⟩ ⊗ |φ⟩ ≠ |φ⟩ ⊗ |ψ⟩ (in general)</li>
                    <li><strong>Dimension:</strong><br>
                        dim(V ⊗ W) = dim(V) × dim(W)</li>
                </ul>
            </div>

            <div class="section full-width">
                <h2>Python Example: Tensor Products</h2>
                
                <div class="code-block">
<pre>import numpy as np

# Define single qubit states
ket_0 = np.array([1, 0])
ket_1 = np.array([0, 1])
ket_plus = np.array([1/np.sqrt(2), 1/np.sqrt(2)])

# Tensor product using np.kron (Kronecker product)
# |00⟩ = |0⟩ ⊗ |0⟩
ket_00 = np.kron(ket_0, ket_0)
print(f"|00⟩ = {ket_00}")

# |01⟩ = |0⟩ ⊗ |1⟩
ket_01 = np.kron(ket_0, ket_1)
print(f"|01⟩ = {ket_01}")

# |10⟩ = |1⟩ ⊗ |0⟩
ket_10 = np.kron(ket_1, ket_0)
print(f"|10⟩ = {ket_10}")

# |11⟩ = |1⟩ ⊗ |1⟩
ket_11 = np.kron(ket_1, ket_1)
print(f"|11⟩ = {ket_11}")

# |+⟩ ⊗ |0⟩
plus_zero = np.kron(ket_plus, ket_0)
print(f"\n|+⟩ ⊗ |0⟩ = {plus_zero}")
print(f"= {plus_zero[0]:.4f}|00⟩ + {plus_zero[2]:.4f}|10⟩")

# Verify normalization
print(f"\nNormalization check: {np.sum(np.abs(plus_zero)**2):.4f}")</pre>
                </div>
            </div>

            <div class="section full-width">
                <h2>Key Takeaways</h2>
                <div class="key-point">
                    <ul>
                        <li>Two-qubit states live in a 4-dimensional Hilbert space</li>
                        <li>The computational basis is {|00⟩, |01⟩, |10⟩, |11⟩}</li>
                        <li>Tensor product combines individual qubit states</li>
                        <li>Kronecker product gives the vector representation</li>
                        <li>This generalizes to n qubits producing 2<sup>n</sup>-dimensional vectors</li>
                    </ul>
                </div>
            </div>
        </div>

        <nav class="nav-buttons">
            <a href="../01-introduction/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../03-product-entangled/index.html" class="btn btn-secondary">Next</a>
        </nav>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let qubit1Sphere, qubit2Sphere, resultSpheres = [];
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            createVisualization();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function createVisualization() {
            // Qubit 1 (left)
            qubit1Sphere = createQubitSphere(-6, 0, 0, 0x00d4ff, "|ψ⟩");
            
            // Qubit 2 (middle-left)
            qubit2Sphere = createQubitSphere(-2, 0, 0, 0xff6b9d, "|φ⟩");
            
            // Tensor product symbol
            addLabel(1, 0, 0, "⊗");
            
            // Result: 4 basis states (right)
            const resultPositions = [
                { x: 5, y: 1.5, z: 1, label: "|00⟩" },
                { x: 7, y: 1.5, z: 1, label: "|01⟩" },
                { x: 5, y: -1.5, z: 1, label: "|10⟩" },
                { x: 7, y: -1.5, z: 1, label: "|11⟩" }
            ];
            
            resultPositions.forEach((pos, i) => {
                const sphere = createResultSphere(pos.x, pos.y, pos.z, 0xffd700, pos.label);
                resultSpheres.push(sphere);
            });
            
            // Connecting lines from inputs to outputs
            createConnectingLines();
        }
        
        function createQubitSphere(x, y, z, color, label) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            // Bloch sphere wireframe
            const sphereGeometry = new THREE.SphereGeometry(1.2, 24, 24);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: color,
                wireframe: true,
                transparent: true,
                opacity: 0.4
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            // State vector
            const arrowGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 16);
            const arrowMaterial = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.y = 0.5;
            group.add(arrow);
            
            const coneGeometry = new THREE.ConeGeometry(0.15, 0.3, 16);
            const cone = new THREE.Mesh(coneGeometry, arrowMaterial);
            cone.position.y = 1.15;
            group.add(cone);
            
            // Label
            addLabelToGroup(group, 0, -2, 0, label);
            
            scene.add(group);
            return group;
        }
        
        function createResultSphere(x, y, z, color, label) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            const sphereGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            addLabelToGroup(group, 0, -0.8, 0, label);
            
            scene.add(group);
            return group;
        }
        
        function createConnectingLines() {
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: 0.3
            });
            
            // Lines from qubit1 to results
            [-6, -2].forEach(startX => {
                resultSpheres.forEach(result => {
                    const points = [
                        new THREE.Vector3(startX, 0, 0),
                        new THREE.Vector3(result.position.x, result.position.y, result.position.z)
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    scene.add(line);
                });
            });
        }
        
        function addLabel(x, y, z, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(2, 2, 1);
            scene.add(sprite);
        }
        
        function addLabelToGroup(group, x, y, z, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(1.5, 0.75, 1);
            group.add(sprite);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Rotate qubit state vectors
            if (qubit1Sphere) {
                qubit1Sphere.children[1].rotation.x = Math.sin(time) * 0.5;
                qubit1Sphere.children[1].rotation.z = Math.cos(time * 0.7) * 0.3;
                qubit1Sphere.children[2].rotation.x = Math.sin(time) * 0.5;
                qubit1Sphere.children[2].rotation.z = Math.cos(time * 0.7) * 0.3;
            }
            
            if (qubit2Sphere) {
                qubit2Sphere.children[1].rotation.x = Math.sin(time + 1) * 0.5;
                qubit2Sphere.children[1].rotation.z = Math.cos(time * 0.7 + 1) * 0.3;
                qubit2Sphere.children[2].rotation.x = Math.sin(time + 1) * 0.5;
                qubit2Sphere.children[2].rotation.z = Math.cos(time * 0.7 + 1) * 0.3;
            }
            
            // Pulse result spheres
            resultSpheres.forEach((sphere, i) => {
                const scale = 1 + Math.sin(time * 2 + i) * 0.1;
                sphere.children[0].scale.set(scale, scale, scale);
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
