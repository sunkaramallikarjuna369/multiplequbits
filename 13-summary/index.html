<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Summary - Multiple-Qubit States</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Concept 13: Summary</h1>
            <p class="subtitle">Complete Overview of Multiple-Qubit States</p>
        </header>

        <nav class="nav-buttons">
            <a href="../12-exercises/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
        </nav>

        <div class="section full-width">
            <h2>Interactive Summary Visualization</h2>
            <div id="canvas-container"></div>
            <p style="text-align: center; margin-top: 10px; opacity: 0.8;">
                A visual representation of the key concepts in multi-qubit quantum systems
            </p>
        </div>

        <div class="content-grid">
            <div class="section full-width">
                <h2>Key Concepts at a Glance</h2>
                
                <div class="summary-grid">
                    <div class="summary-card">
                        <h3>1. Multi-Qubit Hilbert Space</h3>
                        <div class="formula">H<sub>n</sub> = C<sup>2<sup>n</sup></sup></div>
                        <p>n qubits live in a 2<sup>n</sup>-dimensional complex Hilbert space</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>2. Tensor Product</h3>
                        <div class="formula">|ψ⟩ = |ψ<sub>1</sub>⟩ ⊗ |ψ<sub>2</sub>⟩ ⊗ ... ⊗ |ψ<sub>n</sub>⟩</div>
                        <p>Combines individual qubit spaces into composite systems</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>3. Product vs Entangled</h3>
                        <p><strong>Product:</strong> Can be factored into single-qubit states</p>
                        <p><strong>Entangled:</strong> Cannot be factored - quantum correlations</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>4. Bell States</h3>
                        <div class="formula">|Φ<sup>±</sup>⟩ = (|00⟩ ± |11⟩)/√2</div>
                        <div class="formula">|Ψ<sup>±</sup>⟩ = (|01⟩ ± |10⟩)/√2</div>
                        <p>Four maximally entangled two-qubit states</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>5. Exponential Growth</h3>
                        <p>n qubits → 2<sup>n</sup> basis states</p>
                        <p>Source of quantum parallelism and computational power</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>6. CNOT Gate</h3>
                        <p>Flips target qubit when control is |1⟩</p>
                        <p>Essential for creating entanglement</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>7. Creating Entanglement</h3>
                        <div class="formula">CNOT(H ⊗ I)|00⟩ = |Φ<sup>+</sup>⟩</div>
                        <p>Hadamard + CNOT creates Bell states</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>8. Measurement</h3>
                        <div class="formula">P(k) = |α<sub>k</sub>|<sup>2</sup></div>
                        <p>Probability equals amplitude squared; state collapses</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>9. n-Qubit States</h3>
                        <div class="formula">|ψ⟩ = Σ<sub>k</sub> α<sub>k</sub>|k⟩</div>
                        <p>General superposition of 2<sup>n</sup> computational basis states</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>10. Partial Trace</h3>
                        <div class="formula">ρ<sub>A</sub> = Tr<sub>B</sub>(ρ<sub>AB</sub>)</div>
                        <p>Describes subsystems; mixed reduced state indicates entanglement</p>
                    </div>
                    
                    <div class="summary-card">
                        <h3>11. GHZ State</h3>
                        <div class="formula">|GHZ⟩ = (|000⟩ + |111⟩)/√2</div>
                        <p>Maximally entangled three-qubit state</p>
                    </div>
                </div>
            </div>

            <div class="section full-width">
                <h2>Important Formulas Reference</h2>
                
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Formula</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Hilbert Space Dimension</td>
                            <td>dim(H<sub>n</sub>) = 2<sup>n</sup></td>
                            <td>n qubits have 2<sup>n</sup> basis states</td>
                        </tr>
                        <tr>
                            <td>Normalization</td>
                            <td>Σ|α<sub>k</sub>|² = 1</td>
                            <td>Total probability equals 1</td>
                        </tr>
                        <tr>
                            <td>Tensor Product</td>
                            <td>|a⟩ ⊗ |b⟩ = [a₀b₀, a₀b₁, a₁b₀, a₁b₁]<sup>T</sup></td>
                            <td>Kronecker product of vectors</td>
                        </tr>
                        <tr>
                            <td>CNOT Action</td>
                            <td>CNOT|c,t⟩ = |c, t⊕c⟩</td>
                            <td>XOR target with control</td>
                        </tr>
                        <tr>
                            <td>Measurement Probability</td>
                            <td>P(k) = |⟨k|ψ⟩|²</td>
                            <td>Born rule</td>
                        </tr>
                        <tr>
                            <td>Density Matrix</td>
                            <td>ρ = |ψ⟩⟨ψ|</td>
                            <td>Outer product for pure states</td>
                        </tr>
                        <tr>
                            <td>Purity</td>
                            <td>Tr(ρ²) ≤ 1</td>
                            <td>= 1 for pure, < 1 for mixed</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="section full-width">
                <h2>Key Insights</h2>
                
                <div class="key-point">
                    <h3>Quantum Parallelism</h3>
                    <p>The exponential growth of Hilbert space dimension (2<sup>n</sup>) allows quantum computers to process exponentially many states simultaneously through superposition. This is the fundamental source of quantum computational advantage.</p>
                </div>
                
                <div class="key-point">
                    <h3>Entanglement as a Resource</h3>
                    <p>Entanglement is not just a curiosity - it's a key resource for quantum computing, communication, and cryptography. Bell states enable quantum teleportation, superdense coding, and secure key distribution.</p>
                </div>
                
                <div class="key-point">
                    <h3>Measurement and Information</h3>
                    <p>While quantum states can encode exponentially many amplitudes, measurement collapses the state and extracts limited classical information. The art of quantum algorithms is designing interference patterns that amplify correct answers.</p>
                </div>
                
                <div class="key-point">
                    <h3>Classical Simulation Limits</h3>
                    <p>Around 50 qubits, classical simulation becomes practically impossible due to memory requirements (2<sup>50</sup> complex numbers). This is the regime of "quantum supremacy" where quantum computers can outperform classical ones.</p>
                </div>
            </div>

            <div class="section full-width">
                <h2>What's Next?</h2>
                
                <div class="basis-states">
                    <div class="basis-state-card">
                        <h4>Quantum Algorithms</h4>
                        <p>Shor's algorithm, Grover's search, quantum simulation</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>Quantum Error Correction</h4>
                        <p>Protecting quantum information from decoherence</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>Quantum Communication</h4>
                        <p>Teleportation, superdense coding, QKD</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>Quantum Hardware</h4>
                        <p>Superconducting qubits, trapped ions, photonics</p>
                    </div>
                </div>
            </div>

            <div class="section full-width">
                <h2>Quick Reference: Python Code</h2>
                
                <div class="code-block">
<pre>import numpy as np

# === Basic Definitions ===
# Single qubit states
ket_0 = np.array([1, 0])
ket_1 = np.array([0, 1])
ket_plus = np.array([1, 1]) / np.sqrt(2)

# Gates
I = np.eye(2)
X = np.array([[0, 1], [1, 0]])
H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
CNOT = np.array([[1,0,0,0], [0,1,0,0], [0,0,0,1], [0,0,1,0]])

# === Creating States ===
# Tensor product
ket_00 = np.kron(ket_0, ket_0)

# Bell state
bell_phi_plus = CNOT @ np.kron(H, I) @ ket_00

# GHZ state (3 qubits)
ket_000 = np.kron(np.kron(ket_0, ket_0), ket_0)
# Apply H to first qubit, then CNOTs

# === Measurements ===
def measure_probabilities(state):
    return np.abs(state)**2

# === Entanglement Check ===
def is_separable(state_2qubit):
    matrix = state_2qubit.reshape(2, 2)
    _, S, _ = np.linalg.svd(matrix)
    return np.sum(S > 1e-10) == 1

# === Partial Trace ===
def partial_trace_B(rho_AB):
    rho_A = np.zeros((2, 2), dtype=complex)
    for i in range(2):
        for j in range(2):
            for k in range(2):
                rho_A[i, j] += rho_AB[2*i + k, 2*j + k]
    return rho_A</pre>
                </div>
            </div>
        </div>

        <div class="section full-width" style="text-align: center; margin-top: 40px;">
            <h2>Congratulations!</h2>
            <p style="font-size: 1.2em;">You've completed the Multiple-Qubit States guide. You now understand the foundations of multi-qubit quantum systems!</p>
            <a href="../index.html" class="btn btn-primary" style="margin-top: 20px; display: inline-block;">Return to Home</a>
        </div>

        <nav class="nav-buttons">
            <a href="../12-exercises/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
        </nav>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let conceptNodes = [];
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            createVisualization();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function createVisualization() {
            const concepts = [
                { name: 'Tensor\nProduct', color: 0x00d4ff },
                { name: 'Entanglement', color: 0xff6b9d },
                { name: 'Bell\nStates', color: 0xffd700 },
                { name: 'CNOT', color: 0x4caf50 },
                { name: 'Measurement', color: 0x9c27b0 },
                { name: 'GHZ', color: 0xff5722 },
                { name: 'Partial\nTrace', color: 0x00bcd4 },
                { name: 'n-Qubit\nStates', color: 0xe91e63 }
            ];
            
            // Arrange in a circle
            const radius = 8;
            concepts.forEach((concept, i) => {
                const angle = (i / concepts.length) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const node = createConceptNode(x, 0, z, concept.color, concept.name);
                conceptNodes.push(node);
            });
            
            // Central node
            const centralNode = createConceptNode(0, 0, 0, 0xffffff, 'Multi-Qubit\nQuantum\nStates');
            centralNode.scale.set(1.5, 1.5, 1.5);
            conceptNodes.push(centralNode);
            
            // Connect all to center
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.3 });
            concepts.forEach((_, i) => {
                const angle = (i / concepts.length) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const points = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(x, 0, z)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
            });
        }
        
        function createConceptNode(x, y, z, color, label) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            // Label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            const lines = label.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, 128, 50 + i * 25);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const labelSprite = new THREE.Sprite(labelMaterial);
            labelSprite.position.set(0, 2, 0);
            labelSprite.scale.set(3, 1.5, 1);
            group.add(labelSprite);
            
            group.userData = { baseY: y };
            scene.add(group);
            return group;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            conceptNodes.forEach((node, i) => {
                node.position.y = node.userData.baseY + Math.sin(time + i * 0.5) * 0.3;
                node.children[0].rotation.y = time * 0.5;
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>

    <style>
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .summary-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .summary-card:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #00d4ff;
            transform: translateY(-5px);
        }
        
        .summary-card h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }
        
        .summary-card .formula {
            margin: 10px 0;
            font-size: 0.95em;
        }
    </style>
</body>
</html>
