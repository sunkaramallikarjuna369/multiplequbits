<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>General n-Qubit States - Multiple-Qubit States</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Concept 9: General n-Qubit States</h1>
            <p class="subtitle">Expressing Arbitrary Multi-Qubit Pure States</p>
        </header>

        <nav class="nav-buttons">
            <a href="../08-measurement/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../10-partial-trace/index.html" class="btn btn-secondary">Next</a>
        </nav>

        <div class="section full-width">
            <h2>Interactive n-Qubit State Visualization</h2>
            <div id="canvas-container"></div>
            <div class="controls-panel">
                <div class="control-group">
                    <label>Number of Qubits: <span class="value-display" id="n-display">3</span></label>
                    <input type="range" class="slider" id="n-slider" min="1" max="5" value="3">
                </div>
                <div class="state-info">
                    <h4>State Space Information</h4>
                    <p id="space-info">3 qubits: 2³ = 8 basis states, |000⟩ to |111⟩</p>
                </div>
            </div>
        </div>

        <div class="content-grid">
            <div class="section full-width">
                <h2>General n-Qubit Pure State</h2>
                <p>An n-qubit pure state can be expressed as:</p>
                
                <div class="formula">
                    |ψ<sub>n</sub>⟩ = Σ<sub>k=0</sub><sup>2<sup>n</sup>-1</sup> α<sub>k</sub>|k⟩
                </div>
                
                <p>Where:</p>
                <ul>
                    <li>|k⟩ is the computational basis state corresponding to the n-bit binary expansion of k</li>
                    <li>α<sub>k</sub> are complex probability amplitudes</li>
                    <li>The sum runs over all 2<sup>n</sup> basis states</li>
                </ul>
            </div>

            <div class="section">
                <h2>Normalization Condition</h2>
                <p>The state must be normalized:</p>
                
                <div class="formula">
                    Σ<sub>k=0</sub><sup>2<sup>n</sup>-1</sup> |α<sub>k</sub>|<sup>2</sup> = 1
                </div>
                
                <div class="key-point">
                    <strong>Physical Meaning:</strong> The total probability of measuring any outcome must equal 1.
                </div>
            </div>

            <div class="section">
                <h2>Binary Encoding</h2>
                <p>The basis state |k⟩ corresponds to the binary representation of integer k:</p>
                
                <div class="example">
                    <h3>3-Qubit Example</h3>
                    <ul>
                        <li>k=0 → |000⟩</li>
                        <li>k=1 → |001⟩</li>
                        <li>k=2 → |010⟩</li>
                        <li>k=3 → |011⟩</li>
                        <li>k=4 → |100⟩</li>
                        <li>k=5 → |101⟩</li>
                        <li>k=6 → |110⟩</li>
                        <li>k=7 → |111⟩</li>
                    </ul>
                </div>
            </div>

            <div class="section full-width">
                <h2>Computational Basis States</h2>
                
                <table>
                    <thead>
                        <tr>
                            <th>n Qubits</th>
                            <th>Number of Basis States</th>
                            <th>Basis States</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>2</td>
                            <td>|0⟩, |1⟩</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>4</td>
                            <td>|00⟩, |01⟩, |10⟩, |11⟩</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>8</td>
                            <td>|000⟩, |001⟩, |010⟩, |011⟩, |100⟩, |101⟩, |110⟩, |111⟩</td>
                        </tr>
                        <tr>
                            <td>n</td>
                            <td>2<sup>n</sup></td>
                            <td>|0...0⟩ to |1...1⟩ (n bits each)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>Vector Representation</h2>
                <p>An n-qubit state is a column vector of dimension 2<sup>n</sup>:</p>
                
                <div class="formula">
                    |ψ⟩ = [α<sub>0</sub>, α<sub>1</sub>, α<sub>2</sub>, ..., α<sub>2<sup>n</sup>-1</sub>]<sup>T</sup>
                </div>
                
                <p>Each component α<sub>k</sub> is the amplitude for basis state |k⟩.</p>
            </div>

            <div class="section">
                <h2>Special States</h2>
                
                <div class="basis-states">
                    <div class="basis-state-card">
                        <h4>Uniform Superposition</h4>
                        <div class="formula">|+⟩<sup>⊗n</sup> = (1/√2<sup>n</sup>) Σ<sub>k</sub>|k⟩</div>
                        <p>Equal amplitude for all basis states</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>GHZ State</h4>
                        <div class="formula">(|0...0⟩ + |1...1⟩)/√2</div>
                        <p>Maximally entangled n-qubit state</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>W State</h4>
                        <div class="formula">(|100...0⟩ + |010...0⟩ + ... + |0...01⟩)/√n</div>
                        <p>Symmetric entangled state</p>
                    </div>
                </div>
            </div>

            <div class="section full-width">
                <h2>Python Example: n-Qubit States</h2>
                
                <div class="code-block">
<pre>import numpy as np

def create_computational_basis(n):
    """Create all computational basis states for n qubits."""
    dim = 2**n
    basis = {}
    for k in range(dim):
        binary = format(k, f'0{n}b')
        state = np.zeros(dim)
        state[k] = 1
        basis[binary] = state
    return basis

def create_uniform_superposition(n):
    """Create uniform superposition |+⟩^⊗n."""
    dim = 2**n
    return np.ones(dim) / np.sqrt(dim)

def create_ghz_state(n):
    """Create GHZ state (|0...0⟩ + |1...1⟩)/√2."""
    dim = 2**n
    state = np.zeros(dim)
    state[0] = 1/np.sqrt(2)      # |0...0⟩
    state[dim-1] = 1/np.sqrt(2)  # |1...1⟩
    return state

# Example: 3 qubits
n = 3
print(f"=== {n}-Qubit System ===")
print(f"Hilbert space dimension: {2**n}")

# Computational basis
basis = create_computational_basis(n)
print(f"\nComputational basis states:")
for label, state in basis.items():
    print(f"  |{label}⟩ = {state}")

# Uniform superposition
uniform = create_uniform_superposition(n)
print(f"\nUniform superposition |+⟩^⊗{n}:")
print(f"  Amplitudes: {uniform}")
print(f"  Each amplitude: 1/√{2**n} = {1/np.sqrt(2**n):.4f}")

# GHZ state
ghz = create_ghz_state(n)
print(f"\nGHZ state:")
print(f"  State vector: {ghz}")
print(f"  = (|{'0'*n}⟩ + |{'1'*n}⟩)/√2")

# Verify normalization
print(f"\nNormalization checks:")
print(f"  Uniform: {np.sum(np.abs(uniform)**2):.4f}")
print(f"  GHZ: {np.sum(np.abs(ghz)**2):.4f}")</pre>
                </div>
            </div>

            <div class="section full-width">
                <h2>Key Takeaways</h2>
                <div class="key-point">
                    <ul>
                        <li>An n-qubit state is a superposition of 2<sup>n</sup> computational basis states</li>
                        <li>Each basis state |k⟩ corresponds to the binary encoding of integer k</li>
                        <li>The state vector has 2<sup>n</sup> complex amplitudes</li>
                        <li>Normalization ensures total probability equals 1</li>
                        <li>Special states like GHZ and W states have important applications</li>
                    </ul>
                </div>
            </div>
        </div>

        <nav class="nav-buttons">
            <a href="../08-measurement/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../10-partial-trace/index.html" class="btn btn-secondary">Next</a>
        </nav>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let basisStates = [];
        let numQubits = 3;
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 8, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            createVisualization(numQubits);
            setupControls();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function createVisualization(n) {
            // Clear existing
            basisStates.forEach(s => scene.remove(s));
            basisStates = [];
            
            const numStates = Math.pow(2, n);
            const colors = [0x00d4ff, 0xff6b9d, 0xffd700, 0x4caf50, 0x9c27b0, 0xff5722, 0x00bcd4, 0xe91e63];
            
            // Arrange in a circle/sphere
            for (let k = 0; k < numStates; k++) {
                const binary = k.toString(2).padStart(n, '0');
                
                // Position on sphere
                const phi = Math.acos(-1 + (2 * k + 1) / numStates);
                const theta = Math.sqrt(numStates * Math.PI) * phi;
                const radius = 5;
                
                const x = radius * Math.cos(theta) * Math.sin(phi);
                const y = radius * Math.sin(theta) * Math.sin(phi);
                const z = radius * Math.cos(phi);
                
                const group = new THREE.Group();
                group.position.set(x, y, z);
                
                // Sphere for state
                const sphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    color: colors[k % colors.length],
                    emissive: colors[k % colors.length],
                    emissiveIntensity: 0.3
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                group.add(sphere);
                
                // Label
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`|${binary}⟩`, 64, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const label = new THREE.Sprite(labelMaterial);
                label.position.set(0, 0.6, 0);
                label.scale.set(1.5, 0.75, 1);
                group.add(label);
                
                group.userData = { index: k, basePos: { x, y, z } };
                scene.add(group);
                basisStates.push(group);
            }
        }
        
        function setupControls() {
            const slider = document.getElementById('n-slider');
            const nDisplay = document.getElementById('n-display');
            const spaceInfo = document.getElementById('space-info');
            
            slider.addEventListener('input', (e) => {
                numQubits = parseInt(e.target.value);
                nDisplay.textContent = numQubits;
                const dim = Math.pow(2, numQubits);
                const firstState = '0'.repeat(numQubits);
                const lastState = '1'.repeat(numQubits);
                spaceInfo.textContent = `${numQubits} qubits: 2${superscript(numQubits)} = ${dim} basis states, |${firstState}⟩ to |${lastState}⟩`;
                createVisualization(numQubits);
            });
        }
        
        function superscript(n) {
            const sups = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹'];
            return String(n).split('').map(d => sups[parseInt(d)]).join('');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            basisStates.forEach((state, i) => {
                const base = state.userData.basePos;
                state.position.y = base.y + Math.sin(time * 2 + i * 0.5) * 0.2;
                state.children[0].scale.setScalar(1 + Math.sin(time * 3 + i) * 0.1);
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
