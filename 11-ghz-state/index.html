<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHZ State - Multiple-Qubit States</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Concept 11: The GHZ State</h1>
            <p class="subtitle">Three-Qubit Maximally Entangled State</p>
        </header>

        <nav class="nav-buttons">
            <a href="../10-partial-trace/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../12-exercises/index.html" class="btn btn-secondary">Next</a>
        </nav>

        <div class="section full-width">
            <h2>Interactive GHZ State Visualization</h2>
            <div id="canvas-container"></div>
            <div class="controls-panel">
                <button id="measure-btn" style="padding: 15px 30px; background: #00d4ff; border: none; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer; width: 100%;">MEASURE ALL QUBITS</button>
                <div class="state-info" style="margin-top: 15px;">
                    <h4>GHZ State</h4>
                    <p id="state-display">|GHZ⟩ = (|000⟩ + |111⟩)/√2</p>
                    <p id="measurement-result"></p>
                </div>
            </div>
        </div>

        <div class="content-grid">
            <div class="section full-width">
                <h2>The GHZ State</h2>
                <p>The <span class="highlight">GHZ (Greenberger-Horne-Zeilinger)</span> state is a maximally entangled three-qubit state:</p>
                
                <div class="formula">
                    |GHZ⟩ = (|000⟩ + |111⟩)/√2
                </div>
                
                <p>Named after Daniel Greenberger, Michael Horne, and Anton Zeilinger who studied its remarkable properties in 1989.</p>
            </div>

            <div class="section">
                <h2>Properties</h2>
                
                <div class="key-point">
                    <strong>Perfect Correlation:</strong> Measurement of any one qubit collapses all others to the same value.
                </div>
                
                <ul>
                    <li>If qubit 1 measures |0⟩ → qubits 2 and 3 are both |0⟩</li>
                    <li>If qubit 1 measures |1⟩ → qubits 2 and 3 are both |1⟩</li>
                    <li>All three qubits are perfectly correlated</li>
                </ul>
                
                <h3>Measurement Probabilities</h3>
                <ul>
                    <li>P(000) = 1/2</li>
                    <li>P(111) = 1/2</li>
                    <li>All other outcomes: 0</li>
                </ul>
            </div>

            <div class="section">
                <h2>Vector Representation</h2>
                <p>As an 8-dimensional vector:</p>
                
                <div class="formula">
                    |GHZ⟩ = [1/√2, 0, 0, 0, 0, 0, 0, 1/√2]<sup>T</sup>
                </div>
                
                <p>Only the first (|000⟩) and last (|111⟩) components are non-zero.</p>
                
                <div class="example">
                    <h3>Basis State Mapping</h3>
                    <p>Index 0 → |000⟩ (amplitude 1/√2)</p>
                    <p>Index 7 → |111⟩ (amplitude 1/√2)</p>
                </div>
            </div>

            <div class="section full-width">
                <h2>Creating the GHZ State</h2>
                <p>The GHZ state can be created using Hadamard and CNOT gates:</p>
                
                <div class="circuit-container">
                    <pre style="color: #00d4ff; font-size: 1.1em; text-align: center;">
    |0⟩ ──[H]──●────●────  
               │    │      
    |0⟩ ───────⊕────│────  →  (|000⟩ + |111⟩)/√2
                    │      
    |0⟩ ────────────⊕────  
                    </pre>
                </div>
                
                <p>Steps:</p>
                <ol>
                    <li>Apply Hadamard to qubit 1: (|0⟩ + |1⟩)/√2 ⊗ |0⟩ ⊗ |0⟩ = (|000⟩ + |100⟩)/√2</li>
                    <li>Apply CNOT (control=1, target=2): (|000⟩ + |110⟩)/√2</li>
                    <li>Apply CNOT (control=1, target=3): (|000⟩ + |111⟩)/√2 = |GHZ⟩</li>
                </ol>
            </div>

            <div class="section">
                <h2>GHZ vs Bell States</h2>
                
                <table>
                    <thead>
                        <tr>
                            <th>Property</th>
                            <th>Bell State</th>
                            <th>GHZ State</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Qubits</td>
                            <td>2</td>
                            <td>3 (or more)</td>
                        </tr>
                        <tr>
                            <td>Dimension</td>
                            <td>4</td>
                            <td>8</td>
                        </tr>
                        <tr>
                            <td>Entanglement</td>
                            <td>Maximal (2-party)</td>
                            <td>Maximal (3-party)</td>
                        </tr>
                        <tr>
                            <td>Robustness</td>
                            <td>More robust</td>
                            <td>More fragile</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>Applications</h2>
                
                <div class="basis-states">
                    <div class="basis-state-card">
                        <h4>Quantum Communication</h4>
                        <p>Multi-party quantum key distribution and secret sharing</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>Quantum Error Correction</h4>
                        <p>Basis for certain error-correcting codes</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>Bell Inequality Tests</h4>
                        <p>Stronger violations than 2-qubit Bell states</p>
                    </div>
                    <div class="basis-state-card">
                        <h4>Quantum Metrology</h4>
                        <p>Enhanced precision in quantum sensing</p>
                    </div>
                </div>
            </div>

            <div class="section full-width">
                <h2>Python Example: GHZ State</h2>
                
                <div class="code-block">
<pre>import numpy as np

# Gates
I = np.eye(2)
H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)

# CNOT gate
CNOT = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
])

# Initial state |000⟩
ket_000 = np.zeros(8)
ket_000[0] = 1

# Step 1: H on qubit 1 (H ⊗ I ⊗ I)
H_I_I = np.kron(np.kron(H, I), I)
step1 = H_I_I @ ket_000
print(f"After H on qubit 1: {np.round(step1, 4)}")

# Step 2: CNOT(1,2) - control qubit 1, target qubit 2
# Need to construct 8x8 CNOT acting on qubits 1,2
CNOT_12 = np.kron(CNOT, I)
step2 = CNOT_12 @ step1
print(f"After CNOT(1,2): {np.round(step2, 4)}")

# Step 3: CNOT(1,3) - control qubit 1, target qubit 3
# This is trickier - need to swap, apply CNOT, swap back
# Or construct directly
def cnot_13():
    """CNOT with control on qubit 1, target on qubit 3."""
    mat = np.zeros((8, 8))
    for i in range(8):
        bits = [(i >> 2) & 1, (i >> 1) & 1, i & 1]  # q1, q2, q3
        if bits[0] == 1:  # Control is 1, flip target
            bits[2] = 1 - bits[2]
        j = bits[0] * 4 + bits[1] * 2 + bits[2]
        mat[j, i] = 1
    return mat

CNOT_13 = cnot_13()
ghz = CNOT_13 @ step2
print(f"GHZ state: {np.round(ghz, 4)}")

# Verify
print(f"\n|GHZ⟩ = {ghz[0]:.4f}|000⟩ + {ghz[7]:.4f}|111⟩")
print(f"Normalization: {np.sum(np.abs(ghz)**2):.4f}")

# Measurement probabilities
print(f"\nMeasurement probabilities:")
for i in range(8):
    prob = np.abs(ghz[i])**2
    if prob > 0.001:
        binary = format(i, '03b')
        print(f"  P(|{binary}⟩) = {prob:.4f}")</pre>
                </div>
            </div>

            <div class="section full-width">
                <h2>Key Takeaways</h2>
                <div class="key-point">
                    <ul>
                        <li>GHZ state is a maximally entangled 3-qubit state: (|000⟩ + |111⟩)/√2</li>
                        <li>Measuring any qubit collapses all others to the same value</li>
                        <li>Created using Hadamard + two CNOT gates</li>
                        <li>Key resource for quantum communication and error correction</li>
                        <li>Generalizes to n qubits: (|0...0⟩ + |1...1⟩)/√2</li>
                    </ul>
                </div>
            </div>
        </div>

        <nav class="nav-buttons">
            <a href="../10-partial-trace/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../12-exercises/index.html" class="btn btn-secondary">Next</a>
        </nav>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let qubits = [];
        let entanglementLines = [];
        let measured = false;
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            createVisualization();
            setupControls();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function createVisualization() {
            // Three qubits in a triangle
            const positions = [
                { x: 0, y: 2, z: 0 },
                { x: -3, y: -1.5, z: 0 },
                { x: 3, y: -1.5, z: 0 }
            ];
            const colors = [0x00d4ff, 0xff6b9d, 0xffd700];
            const labels = ['Qubit 1', 'Qubit 2', 'Qubit 3'];
            
            positions.forEach((pos, i) => {
                const qubit = createBlochSphere(pos.x, pos.y, pos.z, colors[i], labels[i]);
                qubits.push(qubit);
            });
            
            // Entanglement lines connecting all three
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.6 });
            
            for (let i = 0; i < 3; i++) {
                for (let j = i + 1; j < 3; j++) {
                    const curve = new THREE.QuadraticBezierCurve3(
                        new THREE.Vector3(positions[i].x, positions[i].y, positions[i].z),
                        new THREE.Vector3((positions[i].x + positions[j].x) / 2, (positions[i].y + positions[j].y) / 2 + 1, 0),
                        new THREE.Vector3(positions[j].x, positions[j].y, positions[j].z)
                    );
                    const points = curve.getPoints(30);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial.clone());
                    scene.add(line);
                    entanglementLines.push(line);
                }
            }
        }
        
        function createBlochSphere(x, y, z, color, label) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: color,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            const arrowGroup = new THREE.Group();
            const shaftGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.7, 16);
            const shaftMaterial = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = 0.35;
            arrowGroup.add(shaft);
            
            const coneGeometry = new THREE.ConeGeometry(0.1, 0.2, 16);
            const cone = new THREE.Mesh(coneGeometry, shaftMaterial);
            cone.position.y = 0.8;
            arrowGroup.add(cone);
            
            group.add(arrowGroup);
            group.arrow = arrowGroup;
            
            // Label
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, 64, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const labelSprite = new THREE.Sprite(labelMaterial);
            labelSprite.position.set(0, -1.5, 0);
            labelSprite.scale.set(1.5, 0.75, 1);
            group.add(labelSprite);
            
            scene.add(group);
            return group;
        }
        
        function setupControls() {
            const measureBtn = document.getElementById('measure-btn');
            const measurementResult = document.getElementById('measurement-result');
            const stateDisplay = document.getElementById('state-display');
            
            measureBtn.addEventListener('click', () => {
                measured = true;
                const outcome = Math.random() < 0.5 ? '000' : '111';
                measurementResult.innerHTML = `<strong style="color: #ffd700; font-size: 1.3em;">Result: |${outcome}⟩</strong>`;
                stateDisplay.textContent = `Collapsed to |${outcome}⟩`;
                
                // Update qubit visualization
                const bit = outcome[0];
                qubits.forEach(qubit => {
                    qubit.arrow.rotation.x = bit === '0' ? 0 : Math.PI;
                });
                
                // Reset after 2 seconds
                setTimeout(() => {
                    measured = false;
                    stateDisplay.textContent = '|GHZ⟩ = (|000⟩ + |111⟩)/√2';
                    measurementResult.textContent = '';
                }, 2000);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            if (!measured) {
                // Correlated motion for all three qubits
                const angle = Math.sin(time) * 0.4;
                qubits.forEach(qubit => {
                    qubit.arrow.rotation.x = angle;
                    qubit.arrow.rotation.z = Math.cos(time * 0.7) * 0.2;
                });
                
                // Pulse entanglement lines
                entanglementLines.forEach((line, i) => {
                    line.material.opacity = 0.4 + Math.sin(time * 2 + i) * 0.3;
                });
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
